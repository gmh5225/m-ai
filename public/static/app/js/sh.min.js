(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["SH"] = factory();
	else
		root["SH"] = factory();
})(self, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	// The require scope
/******/ 	var __webpack_require__ = {};
/******/
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/
/************************************************************************/
var __webpack_exports__ = {};
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SimpleHtmlTemplate: () => (/* binding */ SimpleHtmlTemplate),
/* harmony export */   containers: () => (/* binding */ containers),
/* harmony export */   create: () => (/* binding */ create),
/* harmony export */   init: () => (/* binding */ init),
/* harmony export */   options: () => (/* binding */ options),
/* harmony export */   tpl: () => (/* binding */ tpl)
/* harmony export */ });
/**
 * lấy kiểu giá trị của biến
 * @param {*} obj
 * @return {string}
 */
const getType = function (obj) {
  let t = 'null';
  let type = typeof obj;
  if (type == 'object') {
    if (obj === null) {
      t = 'null';
    } else if (obj.constructor == Array || Array.isArray(obj)) {
      t = 'array';
    } else if (obj.constructor == Object) {
      t = 'object';
    } else if (obj.constructor == Number) {
      t = 'number';
    } else {
      t = 'object';
    }
  } else {
    t = type;
  }
  return t;
};
const isFunction = function isFunction(obj) {
  return typeof obj === "function" && typeof obj.nodeType !== "number";
};

/**
 * kiềm tra có phải chuỗi
 * @param {*} variable biến bất kỳ
 */
const isString = function isString(variable) {
  const type = getType(variable);
  return type == "string" || type == "number" && !isNaN(variable) || type == "object" && (variable.constructor == String || variable.isPrimitive && variable.isString);
};
/**
 * kiềm tra có phải array
 * @param {*} variable biến bất kỳ
 */
const isArray = function isArray(variable) {
  return getType(variable) == "array" || Array.isArray(variable);
};
/**
 * kiềm tra có phải object
 * @param {*} variable biến bất kỳ
 */
const isObject = function isObject(variable) {
  return getType(variable) == "object";
};
/**
 * kiềm tra có phải number
 * @param {*} variable biến bất kỳ
 */
const isNumber = function isNumber(variable) {
  const type = getType(variable);
  return (type === "number" || type === "string") && !isNaN(variable - parseFloat(variable)) || type == "object" && (variable.constructor == Number || variable.isPrimitive && variable.isNumber);
};
const isEmpty = function (obj) {
  if (typeof obj == "undefined") return true;

  // console.log(any.constructor)
  const type = getType(obj);
  if (type == "object" && !obj.isPrimitive) {
    for (let key in obj) {
      if (obj.hasOwnProperty(key)) {
        return false;
      }
    }
    return true;
  } else if (type == "array" || type == 'string' || type == "object" && obj.isPrimitive && obj.isString) {
    return obj.length == 0;
  } else return !obj;
};

/**
 * Kiểm tra tồn tại key hay ko?
 * @param {object|array} obj doi tuong can kiem tra
 * @param {string} key
 * @returns {boolean}
 */
function objectHasKey(obj, key) {
  return isObject(obj) && isString(key) && Object.hasOwnProperty.call(obj, key);
}

/**
 * kiểm tra sự tồn tại của thuộc tinh thông qua key và kiểu giá trị
 * @param {any} obj doi tuong can kiem tra
 * @param {string} key danh sach key kem kiey gia tri
 * @param {string} type kieu gia tri
 * @returns {boolean}
 */
function objectHasProperty(obj, key, type) {
  if (!isObject(obj) || isEmpty(obj) || typeof key == "undefined" || !isString(key) && !isArray(key)) return false;
  var keys = isArray(key) ? key : [key + (isString(type) ? ":" + type : "")];
  for (var i = 0; i < keys.length; i++) {
    var k = keys[i];
    var ks = k.split(':');
    var kv = ks[0];
    if (!objectHasKey(obj, kv)) return false;
    if (ks.length == 2) {
      var b = ks[1].split('|').map(function (t) {
        return t.trim();
      }).filter(function (vl) {
        return vl.length > 0;
      });
      if (b.length && !inArray(b, getType(obj[kv]))) return false;
    }
  }
  return true;
}

/**
 *
 * @param obj
 * @param key
 * @param delimiter
 * @returns
 */
const getEl = function (obj, key, defaultValue, delimiter) {
  if (typeof obj == 'undefined') {
    return null;
  }
  if (typeof key == 'undefined') {
    return obj;
  }
  var tpo = getType(obj);
  var tpk = getType(key);
  if (tpo == 'array') {
    var k = NaN;
    if (tpk == 'number') {
      k = key;
    } else if (parseInt(key) != NaN) {
      k = parseInt(key);
    }
    if (!isNaN(k)) {
      if (typeof obj[k] != 'undefined') {
        return obj[k];
      }
    }
  } else if (tpo == "object") {
    var c = obj;
    var d = isString(delimiter) ? delimiter : '.';
    var ks = String(key).split(d);
    for (let index = 0; index < ks.length; index++) {
      const e = ks[index];
      if (typeof c[e] != "undefined") {
        c = c[e];
      } else {
        c = defaultValue;
      }
      if (index < ks.length - 1 && (!isObject(c) && !isArray(c) || c === defaultValue)) return defaultValue;
    }
    return c;
  }
  return defaultValue;
};
const Num = {
  rand: function (from, to) {
    if (!from) from = 0;
    if (!to) to = 0;
    if (from == 0) to++;
    var rand = Math.floor(Math.random() * to) + from;
    return rand;
  }
};
var convertedArray = [];
const Str = {
  isSN: function (str) {
    if (typeof str == 'undefined') return null;
    var t = getType(str);
    if (t == 'string' || t == 'number') return true;
    return false;
  },
  /**
   * thay thế chuỗi
   * @param {string} subject chuỗi muốn tìm và thay thế giá trị bên trong nó
   * @param {string|array|object} search Giá trị cần tìm
   * @param {string} replace Giá trị muốn thay thế
   * @returns {string}
   */
  replace: function () {
    var a = getArguments(arguments);
    var t = a.length;
    if (t == 0) return '';
    if (typeof a[0] != 'string' || t < 2) {
      return a[0];
    }
    var str = a[0];
    var b = getType(a[1]);
    if (this.isSN(a[1])) {
      if (t >= 3 && this.isSN(a[2])) {
        var obj = Object.create({});
        obj[a[1]] = a[2];
        str = this.replaceByObj(str, obj);
      }
    } else if (b == 'array') {
      if (t >= 3 && getType(a[2]) == 'array') {
        str = this.replaceByArr(str, a[1], a[2]);
      } else if (t >= 3 && getType(a[2]) == 'string') {
        var obj = Object.create({}),
          val = a[2];
        var d = a[1];
        for (var k in d) {
          obj[d[k]] = val;
        }
        str = this.replaceByObj(str, obj);
      }
    } else if (b == 'object') {
      str = this.replaceByObj(str, a[1]);
    }
    return str;
  },
  replaceByArr: function () {
    var a = getArguments(arguments);
    var t = a.length;
    if (t == 0) return '';
    if (typeof a[0] != 'string' || t < 2) {
      return a[0];
    }
    var str = a[0];
    var b = getType(a[1]);
    if (b == 'object') {
      str = this.replaceByObj(str, a[1]);
    } else if (b == 'array') {
      var obj = emptyObject();
      if (t >= 3) {
        var f = getType(a[2]);
        if (f == 'string') {
          for (var k in a[1]) {
            obj[a[1][k]] = a[2];
          }
        } else if (f == 'array') {
          var e = a[1].length,
            g = a[2].length;
          var max = e > g ? e : g;
          for (var i = 0; i < max; i++) {
            obj[a[1][i]] = a[2][i];
          }
        }
      }
      str = this.replaceByObj(str, obj);
    }
    return str;
  },
  replaceByObj: function () {
    var a = getArguments(arguments);
    // var a = arguments;
    var t = a.length;
    if (t == 0) return '';
    if (typeof a[0] != 'string' || t < 2) {
      return a[0];
    }
    var str = a[0];
    var b = getType(a[1]);
    if (b == 'object') {
      var max = null;
      if (typeof a[2] == 'number') {
        max = a[2];
      }
      var i = 1;
      var sts = a[1];
      for (var key in sts) {
        var txt = sts[key];
        str = this.preg_replace(key, txt, str);
        if (max && i >= max) break;
        i++;
      }
    }
    return str;
  },
  escapeRegExp: function (str) {
    var s = "" + str + "";
    return s.replace(/([.*+?^=!:${}()|\[\]\/\\])/g, "\\$1");
  },
  preg_replace: function (find, replace, str) {
    var str = "" + str + "";
    return str.replace(new RegExp(this.escapeRegExp(find), 'g'), replace);
  },
  /**
   * Tạo một chuỗi random Ngẫu nhiên
   * @param {string} charList chuỗi ký tự bổ xung
   * @returns {string}
   */
  rand: function (charList) {
    var st = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
    if (charList && isString(charList)) st = st + String(charList);
    var sp = st.split('');
    var l = sp.length - 1;
    var s = '';
    for (var i = 0; i < 32; i++) {
      s += sp[Num.rand(0, l)];
    }
    return s;
  },
  eval: function (template, data) {
    var t = typeof data;
    var tpl = template;
    if (t == 'object' || t == "array") {
      data = this.convertTextObject({}, data);
      for (var k in data) {
        var val = data[k];
        if (val === null) val = '';
        var f = "\{\$" + k + "\}";
        tpl = this.replace(tpl, f, val);
      }
    }
    return tpl;
  },
  convertTextObject: function (root, object, name, joinKey) {
    if (inArray(convertedArray, object)) return root;
    for (var key in object) {
      if (object.hasOwnProperty(key)) {
        if (typeof joinKey != "string") joinKey = ".";
        var val = object[key];
        var t = typeof val;
        var k = typeof name != "undefined" && ("" + name).length ? name + joinKey + key : key;
        if (val != null && (t == 'object' || t == "array")) {
          root = this.convertTextObject(root, val, k, joinKey);
        } else {
          root[k] = val;
        }
      }
    }
    convertedArray.push(object);
    return root;
  },
  objectKey: function (str, key) {
    if (!key) key = '_';
    var s = String(str);
    var l = '$ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
    var list = [];
    var n = 0;
    var t = this.replace(this.replace(this.clearUnicode(s), "[]{}();:'\"\\|,./?~!@#$%^&*+=".split(""), "-"), '--', '-');
    for (var i = 0; i < t.length; i++) {
      var st = t[i];
      if (l.indexOf(st) == -1) {
        if (typeof list[n] != "undefined") {
          if (l.indexOf(t[i - 1]) >= 0) n++;
        }
      } else {
        if (typeof list[n] == "undefined") {
          list[n] = st;
        } else {
          list[n] += st;
        }
      }
    }
    ;
    return list.join(key);
  }
};
const components = {
  "@for": function (config, template) {},
  "@forin": function (config, template) {},
  "@forof": function (config, template) {},
  "@foreach": function (config, template) {}
};
/**
 *
 * @param obj
 * @param key
 * @param delimiter
 * @returns
 */
var getObjectMethod = function (obj, key, defaultValue, delimiter) {
  if (typeof obj == 'undefined') {
    return null;
  }
  if (typeof key == 'undefined') {
    return obj;
  }
  var tpo = getType(obj);
  var tpk = getType(key);
  if (tpo == 'array') {
    var k = NaN;
    if (tpk == 'number') {
      k = key;
    } else if (parseInt(key) != NaN) {
      k = parseInt(key);
    }
    if (!isNaN(k)) {
      if (typeof obj[k] == 'function') {
        return function () {
          obj[k].apply(obj, getArguments(arguments));
        };
      } else return getObjectMethod(window, key, defaultValue, delimiter);
    }
  } else if (tpo == "object") {
    var c = obj;
    var parent = null;
    var d = isString(delimiter) ? delimiter : '.';
    var ks = String(key).split(d);
    for (let index = 0; index < ks.length; index++) {
      const e = ks[index];
      if (obj == window && index == 0 && e == 'window') continue;else if (index == 0 && obj != window && !objectHasKey(obj, e)) {
        if (ks.length == 1 && objectHasKey(containers, e)) {
          return function () {
            return containers[e].render.apply(containers[e], getArguments(arguments));
          };
        }
        return getObjectMethod(window, key, defaultValue, d);
      }
      if (objectHasKey(c, e)) {
        parent = c;
        c = c[e];
      } else if (index == ks.length - 1 && typeof c[e] == "function") {
        parent = c;
        c = c[e];
      } else {
        c = defaultValue;
      }
      if (index < ks.length - 1 && !isObject(c) && !isArray(c)) {
        console.log(obj, key, parent, c);
        return defaultValue;
      }
    }
    return !isFunction(c) ? function () {} : function () {
      var args = getArguments(arguments);
      return c.apply(parent, args);
    };
  }
  return function () {};
};

/**
 * lấy danh sách tham số nội hàm khi dược gọi
 * @param {Arguments} args tham số nội hàm
 * @param {integer} start vị trí bắt đầu lấy tham số
 * @returns {mixed[]}
 */
function getArguments(args, start) {
  var a = [];
  if (!isNumber(start) || start < 0) start = 0;
  if (args && args.length) {
    for (let i = start; i < args.length; i++) {
      const arg = args[i];
      a.push(arg);
    }
  }
  return a;
}
const parseStrFnParams = function (str) {
  const containers = [{
    type: "variable",
    str: "",
    params: ""
  }];
  let inFunction = 0;
  let inString = false;
  let strChar = '';
  let currentIndex = 0;
  str.split("").map((c, i) => {
    // console.log(c)
    if (c == '"' || c == "'") {
      if (c == strChar) {
        inString = false;
        strChar = '';
        if (inFunction) {
          containers[currentIndex].params += c;
        }
      } else if (inFunction) {
        containers[currentIndex].params += c;
        if (!inString) {
          inString = true;
          strChar = c;
        }
      } else if (!inString) {
        inString = true;
        strChar = c;
        if (!inFunction) containers[currentIndex].type = 'string';
      } else {
        containers[currentIndex].str += c;
      }
    } else if (c == " ") {
      if (inFunction) {
        containers[currentIndex].params += c;
      } else if (inString) {
        containers[currentIndex].str += c;
      } else if (containers[currentIndex].type == 'variable') {
        // if()
      } else {}
    } else if (c == ',') {
      if (inFunction) {
        containers[currentIndex].params += c;
      } else if (inString) {
        containers[currentIndex].str += c;
      } else {
        if (containers[currentIndex].type != 'string') {
          containers[currentIndex].str = containers[currentIndex].str.trim();
        }
        if (containers[currentIndex].type == 'variable') {
          if (isNumber(containers[currentIndex].str)) {
            containers[currentIndex].str = Number(containers[currentIndex].str);
          }
        }
        currentIndex++;
        containers.push({
          type: "variable",
          str: "",
          params: ""
        });
      }
    } else if (c == ')') {
      if (inFunction) {
        if (!inString) {
          inFunction--;
          if (inFunction == 0) {
            containers[currentIndex].args = parseStrFnParams(containers[currentIndex].params);
            if (containers[currentIndex].type != 'string') {
              containers[currentIndex].str = containers[currentIndex].str.trim();
            }
            if (isNumber(containers[currentIndex].str)) {
              containers[currentIndex].str = Number(containers[currentIndex].str);
            }
            currentIndex++;
            containers.push({
              type: "variable",
              str: "",
              params: ""
            });
          } else {
            containers[currentIndex].params += c;
          }
        } else {
          containers[currentIndex].params += c;
        }
      } else {
        containers[currentIndex].str += c;
      }
    } else if (c == '(') {
      if (!inFunction) {
        if (containers[currentIndex].str != '') {
          inFunction++;
          containers[currentIndex].type = 'function';
        } else {
          throw new Error("cú pháp không hợp lệ tại vị trí: " + i);
        }
      } else {
        if (!inString) inFunction++;
        containers[currentIndex].params += c;
      }
      // console.log("inFunction", inFunction)
    } else if (inFunction) {
      containers[currentIndex].params += c;
    } else {
      containers[currentIndex].str += c;
    }
  });
  if (containers[containers.length - 1].str == '' && containers[containers.length - 1].type == 'variable') {
    containers.pop();
  }
  // console.log(inFunction)
  return containers;
};
const stringAnalysis = function (str) {
  const containers = [{
    type: "variable",
    str: "",
    params: ""
  }];
  var inFunction = 0;
  var inString = false;
  var strChar = '';
  var currentIndex = 0;
  str.split("").map((c, i) => {
    // console.log(c)
    if (c == '"' || c == "'") {
      if (c == strChar) {
        inString = false;
        strChar = '';
        if (inFunction) {
          containers[currentIndex].params += c;
        }
      } else if (inFunction) {
        containers[currentIndex].params += c;
        if (!inString) {
          inString = true;
          strChar = c;
        }
      } else if (!inString) {
        inString = true;
        strChar = c;
        if (!inFunction) containers[currentIndex].type = 'string';
      } else {
        containers[currentIndex].str += c;
      }
    } else if (c == " ") {
      if (inFunction) {
        containers[currentIndex].params += c;
      } else if (inString) {
        containers[currentIndex].str += c;
      } else if (containers[currentIndex].type == 'variable') {
        // if()
      } else {}
    } else if (c == ';') {
      if (!inFunction && !inString) {
        if (containers[currentIndex].type != 'string') {
          containers[currentIndex].str = containers[currentIndex].str.trim();
        }
        if (isNumber(containers[currentIndex].str)) {
          containers[currentIndex].str = Number(containers[currentIndex].str);
        }
        currentIndex++;
        containers.push({
          type: "variable",
          str: "",
          params: ""
        });
      } else if (inString) {
        if (inFunction) {
          containers[currentIndex].params += c;
        } else {
          containers[currentIndex].str += c;
        }
      } else if (inFunction) {
        containers[currentIndex].params += ',';
      }
    } else if (c == ',') {
      if (inFunction) {
        containers[currentIndex].params += c;
      } else {
        containers[currentIndex].str += c;
      }
    } else if (c == ')') {
      if (inFunction) {
        if (!inString) {
          inFunction--;
          if (inFunction == 0) {
            containers[currentIndex].args = parseStrFnParams(containers[currentIndex].params);
            if (containers[currentIndex].type != 'string') {
              containers[currentIndex].str = containers[currentIndex].str.trim();
            }
            if (isNumber(containers[currentIndex].str)) {
              containers[currentIndex].str = Number(containers[currentIndex].str);
            }
            currentIndex++;
            containers.push({
              type: "variable",
              str: "",
              params: ""
            });
          } else {
            containers[currentIndex].params += c;
          }
        } else {
          containers[currentIndex].params += c;
        }
      } else {
        containers[currentIndex].str += c;
      }
    } else if (c == '(') {
      if (!inFunction) {
        if (containers[currentIndex].str != '') {
          inFunction++;
          containers[currentIndex].type = 'function';
          if (containers[currentIndex].type != 'string') {
            containers[currentIndex].str = containers[currentIndex].str.trim();
          }
        } else {
          throw new Error("cú pháp không hợp lệ tại vị trí: " + i);
        }
      } else {
        if (!inString) inFunction++;
        containers[currentIndex].params += c;
      }
      // console.log("inFunction", inFunction)
    } else if (inFunction) {
      containers[currentIndex].params += c;
    } else {
      containers[currentIndex].str += c;
    }
  });
  if (containers[containers.length - 1].str == '' && containers[containers.length - 1].type == 'variable') {
    containers.pop();
  }
  // console.log(inFunction)
  return containers; //.shift();
};
function BindingText(key) {
  this.key = String(key).trim();
  this.isBindingText = true;
  this.type = 'self';
}
const parseTextData = str => {
  if (!isString(str)) return {
    template: str,
    bindings: []
  };
  let s = String(str);
  let sTPL = String(str);
  let a = /\{\s*[^\}]+\s*\}/i.test(s);
  if (!a) return {
    template: str,
    bindings: []
  };
  let texts = [""];
  let n = 0;
  let keys = [];
  let dboKeys = [];
  let last = '';
  let isOpen = false;
  let currentKey = '';
  let data = [];
  let isStringOpened = false;
  let openedChar = '';
  let markIndex = 1;
  for (let i = 0; i < s.length; i++) {
    const c = s[i];
    if (isOpen) {
      if (c == '{') {
        texts[n] = c;
        // isOpen = false;
        if (isStringOpened) currentKey += c;else currentKey = '';
      } else if (c == '}') {
        texts[n] += c;
        if (isStringOpened) currentKey += c;else {
          let cv = currentKey.trim();
          let bidding = "[@binding:key=" + markIndex + "]";
          data.push({
            key: cv,
            template: texts[n],
            mark: bidding,
            bindings: stringAnalysis(cv)
          });
          sTPL = Str.replace(sTPL, texts[n], bidding);
          markIndex++;
          currentKey = '';
          n++;
          last = '';
          isOpen = false;
          if (i < s.length - 1) texts[n] = '';
        }
      } else {
        if (["'", '"'].indexOf(c) != -1) {
          if (isStringOpened) {
            if (openedChar == c) {
              isStringOpened = false;
            }
          } else {
            isStringOpened = true;
            openedChar = c;
          }
        }
        texts[n] += c;
        currentKey += c;
      }
    } else if (c == '{') {
      isOpen = true;
      texts[n] = c;
    }
    if (!i || last != '') last = c;
  }
  if (texts[0] == '') {
    texts.shift();
  }
  return {
    template: sTPL,
    bindings: data
  };
};
function SimpleHtmlTemplate(str, root) {
  this.template = '';
  this.data = {};
  this.actions = [];
  let self = this;
  this.root = root;
  const init = () => {
    let a = /^[A-z0-9_\-]+$/i.test(str);
    if (a) {
      let el = document.getElementById(str);
      if (el) {
        self.template = el.innerHTML;
        let role = el.getAttribute('role');
        if (role) {
          if (!objectHasKey(containers, role)) {
            containers[role] = self;
          }
        }
        el.parentNode.removeChild(el);
      }
    }
    let analysis = parseTextData(str);
    if (!self.template) self.template = analysis.template;
    self.actions = analysis.bindings;
  };
  this.parseMethodArgs = function (params) {
    var args = [];
    if (isArray(params)) {
      for (let index = 0; index < params.length; index++) {
        const p = params[index];
        switch (p.type) {
          case 'function':
            args.push(getObjectMethod(this.data, p.str).apply(this.data, this.parseMethodArgs(p.args)));
            break;
          case 'variable':
            args.push(getEl(this.data, p.str));
            break;
          default:
            args.push(p.str);
            break;
        }
      }
    }
    return args;
  };
  this.renderData = function (data) {
    var actions = this.actions;
    this.data = data;
    var renderedData = {};
    let returnData = [];
    for (let i = 0; i < actions.length; i++) {
      const fnData = actions[i];
      let k = fnData.key;
      if (!objectHasKey(renderedData, k)) {
        let d = this.parseMethodArgs(fnData.bindings).join("");
        renderedData[k] = d;
      }
      returnData.push({
        data: renderedData[k],
        template: fnData.mark
      });
    }
    this.data = {};
    return returnData;
  };
  this.render = function (data, root) {
    let dataList = this.renderData(data);
    let html = this.template;
    dataList.map(d => html = Str.replace(html, d.template, d.data));
    if (root && root instanceof Element) {
      root.innerHTML = html;
    } else if (this.root && this.root instanceof Element) {
      this.root.innerHTML = html;
    }
    return html;
  };
  init();
}

const create = (tpl, root) => {
  return new SimpleHtmlTemplate(tpl, root);
};
const containers = {};
const options = {
  selector: 'script[type="text/template"][role],script[type="text/html"][role]'
};
const init = () => {
  let scripts = document.querySelectorAll(options.selector);
  let list = {};
  if (scripts.length) {
    for (let index = 0; index < scripts.length; index++) {
      const element = scripts[index];
      let template = element.innerHTML;
      let role = element.getAttribute('role');
      let tpl = new SimpleHtmlTemplate(template);
      if (role) {
        containers[role] = tpl;
        list[role] = tpl;
      }
      element.parentNode.removeChild(element);
    }
  }
};
const tpl = role => objectHasKey(containers, role) ? containers[role] : create(role);
/******/ 	return __webpack_exports__;
/******/ })()
;
});
